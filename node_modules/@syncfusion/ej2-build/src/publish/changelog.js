'use strict';

var fs = global.fs = global.fs || require('fs');
var gulp = global.gulp = global.gulp || require('gulp');
var common = global.config = global.config || require('../utils/common.js');
var shelljs = global.shelljs = global.shelljs || require('shelljs');
var md2json = require('md-2-json');
var changelogPath = {
    'typescript': './CHANGELOG.md',
    'angular': './third-party/changelog/angular.md',
    'react': './third-party/changelog/react.md',
    'vue': './third-party/changelog/vue.md',
    'aspnetcore': './third-party/changelog/aspnetcore.md',
    'aspnetmvc': './third-party/changelog/aspnetmvc.md'
};
var commonPackage = {
    'ej2-base': 'typescript',
    'ej2-angular-base': 'angular',
    'ej2-react-base': 'react',
    'ej2-vue-base': 'vue'
};
var versios = {
    'vue': 16.2
};
var chalogRegex = /changelog/i;
var versionCheckRegex = /^(\d+\.)?(\d+\.)?(\*|\d+).+/;
var changeLogtypes = ['Bug Fixes', 'New Features', 'Breaking Changes', 'Deprecated'];

gulp.task('changelog-validation', function () {
    if ((process.env.BRANCH_NAME !== undefined) && (process.env.BRANCH_NAME === 'master' || process.env.BRANCH_NAME.startsWith('release/') ||
        process.env.BRANCH_NAME.startsWith('hotfix/'))) {
        return;
    }
    var differences = shelljs.exec('git diff --name-only HEAD').stdout.split('\n');
    console.log('differences ---> ' + differences);
    for (var i = 0; i < differences.length; i++) {
        var isSyntaxError = false;
        var file = differences[i];
        if (file.indexOf('.md') !== -1 && file.indexOf('README.md') === -1 && chalogRegex.test(file)) {
            var mdContent = fs.readFileSync(file, 'utf8');
            var mdObj = md2json.parse(mdContent).Changelog;
            var versionName = Object.keys(mdObj);
            for (var j = 0; j < versionName.length; j++) {
                var comp = mdObj[versionName[j]];
                var compName = Object.keys(comp);
                if (versionCheckRegex.test(versionName[j]) || versionName[j] === '[Unreleased]') {
                    if (Object.keys(comp).length === 0) {
                        continue;
                    }
                    for (var k = 0; k < compName.length; k++) {
                        isSyntaxError = changeLogtypes.indexOf(compName[k]) !== -1 || compName[k] === `raw`;
                        var compKey = comp[compName[k]];
                        var change = Object.keys(compKey);
                        for (var l = 0; l < change.length; l++) {
                            isSyntaxError = changeLogtypes.indexOf(change[l]) === -1 && change[l] !== 'raw';
                        }
                    }
                } else {
                    isSyntaxError = true;
                }
                if (isSyntaxError) {
                    console.log('syntax error in the changelog --------> ' + file);
                    console.log('Component version --------> ' + versionName[j]);
                    process.exit(1);
                }
            }
        }
    }
});

gulp.task('publish-changelog', function () {
    if (process.env.BRANCH_NAME !== 'master' && !process.env.BRANCH_NAME.startsWith('release/') &&
        !process.env.BRANCH_NAME.startsWith('hotfix/')) {
        return;
    }
    var user = 'SyncfusionBuild';
    var token = process.env.GithubBuildAutomation_PrivateToken;
    var branch = process.env.BRANCH_NAME;
    var origin = 'https://' + user + ':' + token + '@github.com/essential-studio/ej2-release-notes.git';
    // checkout ej2-release-notes in eh2-changelog location
    shelljs.exec('git clone ' + origin + ' -b ' + branch + ' ./ej2-changelog');
    var platforms = Object.keys(changelogPath);
    var basePackages = Object.keys(commonPackage);
    if (basePackages.indexOf(global.config.currentPackage) > -1) {
        platforms = [commonPackage[global.config.currentPackage]];
    }
    for (var i = 0; i < platforms.length; i++) {
        if (!fs.existsSync('./ej2-changelog/src/' + platforms[i])) {
            // create the folder path
            shelljs.mkdir('-p', './ej2-changelog/src/' + platforms[i]);
        }
        mergeChangelog(platforms[i]);
    }
    // navigate into ej2-changelog folder
    shelljs.cd('./ej2-changelog');
    // pull the remote changes
    shelljs.exec('git pull', { silent: false });
    // add all new changes in the git
    shelljs.exec('git add .', { silent: false });
    // commit the new changes
    shelljs.exec('git commit -m "' + common.currentPackage + ' release-notes are merged"', { silent: false });
    // push the commited changes to remote
    shelljs.exec('git push -f --set-upstream origin ' + branch + ' --no-verify', { silent: false });
    // navigate to root folder
    shelljs.cd('../');
    // remove ej2-changelog folder
    shelljs.rm('-rf', './ej2-changelog');
});

function mergeChangelog(platform) {
    var isAspNet = platform === 'aspnetcore' || platform === 'aspnetmvc';
    if (!fs.existsSync(changelogPath.typescript)) {
        return;
    }
    if (!isAspNet) {
        getChangelog(platform, changelogPath.typescript);
        var isThirdPartyExist = fs.existsSync(changelogPath[platform]);
        if (platform !== 'typescript' && isThirdPartyExist) {
            getChangelog(platform, changelogPath[platform], isThirdPartyExist);
        }
    }
    if (isAspNet && fs.existsSync(changelogPath[platform])) {
        getChangelog(platform, changelogPath[platform]);
    }
}

function getChangelog(platform, mdPath, isThirdParty) {
    // read the changelog file
    var changelog = fs.readFileSync(mdPath, 'utf8');
    // parse the changelog to JSON format
    var changelogJson = md2json.parse(changelog).Changelog;
    var keys = Object.keys(changelogJson);
    for (var i = 0; i < keys.length; i++) {
        var filePath = './ej2-changelog/src/' + platform + '/';
        var fullPath = filePath + keys[i] + '.md';
        if (versios[platform] && keys[i] !== '[Unreleased]' && parseFloat(keys[i]) < versios[platform]) {
            continue;
        }
        if (fs.existsSync(fullPath)) {
            var merged;
            // convert current changelog json to md format
            var currentChangelog = changelogJson[keys[i]];
            // convert existing changelog to json
            var prevChanglog = md2json.parse(fs.readFileSync(fullPath, 'utf8'));
            if (!isThirdParty) {
                // merge the new changes to existing changelog
                merged = Object.assign(prevChanglog, currentChangelog);
            } else {
                // merge the third-party changelog with existing changelog
                merged = mergeThirdPartyChangelog(currentChangelog, prevChanglog);
            }
            // get distict changelog
            removeDuplicateLines(merged);
            // get sorted changelog
            var sortedChangelog = getSortedChangelog(merged, true);
            // convert merged changelog json to md format
            var mergedChangelog = md2json.toMd(sortedChangelog);
            // write the changelog to ej2-release-notes
            fs.writeFileSync(fullPath, mergedChangelog);
        } else {
            // convert current changelog json to md format
            var releaseNotes = md2json.toMd(changelogJson[keys[i]]);
            // write the changelog to ej2-release-notes
            fs.writeFileSync(fullPath, releaseNotes);
        }
    }
}

function removeDuplicateLines(jsonObj) {
  //  var ikeys = Object.keys(jsonObj);
    for (var curComponent in jsonObj) {
        var curObj = jsonObj[curComponent];
        for (var curProp in curObj) {
            if (curProp === 'raw' || !curObj[curProp].raw) {
                continue;
            }
            var curInput = curObj[curProp].raw.split('\n');
            curObj[curProp].raw = curInput.filter(function (line, index, lines) {
                if (line) {
                    return lines.indexOf(line) === index;
                } else {
                    return true;
                }
            }).join('\n');
        }
    }
}
function getSortedChangelog(jsonObj, isSort) {
    var keys = Object.keys(jsonObj);
    keys.sort();
    var commonIndex = keys.indexOf('Common');
    if (commonIndex !== -1) {
        keys.splice(commonIndex, 1);
        keys.splice(0, 0, 'Common');
    }
    var sortedChangelog = {};
    for (var i = 0; i < keys.length; i++) {
        if (isSort) {
            sortedChangelog[keys[i]] = getSortedChangelog(jsonObj[keys[i]]);
        } else {
            sortedChangelog[keys[i]] = jsonObj[keys[i]];
        }
    }
    return sortedChangelog;
}

function mergeThirdPartyChangelog(srcObj, destObj) {
    // get current changelog keys
    var compKeys = Object.keys(srcObj);
    for (var i = 0; i < compKeys.length; i++) {
        // compKey will be Common | Button | etc..
        var compKey = compKeys[i];
        // get third-party changelog
        var srcChangelog = srcObj[compKey];
        // get ej2-release-notes changelog
        var destChangelog = destObj[compKey];
        var typeKeys = Object.keys(srcChangelog);
        for (var j = 0; j < typeKeys.length; j++) {
            // keyType will be New Features | Bug Fixes | Breaking Changes
            var keyType = typeKeys[j];
            // check ej2-release-notes already have the keyType
            if (destChangelog && destChangelog[keyType] && destChangelog[keyType].raw &&
                srcChangelog[keyType] && srcChangelog[keyType].raw) {
                // add third-party changelog with ej2-release-notes changelog
                destObj[compKey][keyType].raw = srcChangelog[keyType].raw + destChangelog[keyType].raw;
            } else {
                // create third-party changelog in ej2-release-notes
                destObj[compKey] = destChangelog ? destChangelog : {};
                destObj[compKey][keyType] = srcChangelog[keyType];
            }
        }
    }
    return destObj;
}
