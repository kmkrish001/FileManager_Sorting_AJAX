'use strict';

var gulp = global.gulp = global.gulp || require('gulp');
var common = global.config = global.config || require('../utils/common.js');
var fs = global.fs = global.fs || require('fs');
var path = global.path = global.path || require('path');
var shelljs = global.shelljs = global.shelljs || require('shelljs');
var glob = require('glob');
var cdn = require('./cdn.js');
var user = 'SyncfusionBuild';
var token = process.env.GithubBuildAutomation_PrivateToken;
var regexp = common.regexp;
var currentRepo = common.currentRepo;
var runSequence = require('run-sequence');
var branch = process.env.BRANCH_NAME;
var themes = ['material', 'fabric', 'bootstrap', 'highcontrast', 'material-dark', 'fabric-dark', 'bootstrap-dark'];
var gzip = require('gulp-gzip');

var productionIgnore =
    `.npmrc
**/*.ts
**/*.tsx
**/*.log
!**/*.d.ts
api.**/
spec/
demo/
demos/
aot/
blazor/
ej2-docs/
api-code-blocks/
ej2-resources/
ej2-js-es5/
public/
.git/
archive/
.vscode/
coverage/
cireports/
accessibility/
tempFile
shelljs_*
.npmignore
.gitignore
config.json
api.json
*.docx
help.md
CHANGELOG.md
pipeline.cmd
system.config.js
gulpfile.js
test-report/
github-repo/
test-main.js
tsconfig.json
rollup.config.js
tsconfig-aot.json
node-modules/
karma.conf.js
Jenkinsfile
coverage.txt
yarn.lock
.spelling
umd-deploy/
third-party/
dist/ts/
targetBranch.txt
coverage-cdn/
cireports/
compare-api.json
current-api.json
api-changes.html
branchPackage.tgz
dist/global/blazor/
dist/global/*.js
.gitlab/
blazor-source/
**/index-all.js
schematics-samples/
!schematics/generators/template/**/*.ts
!schematics/generators/*/samples/**/*.ts` +
    '\n!dist/global/' + common.currentPackage + '.min.js' +
    '\ndist/' + common.currentPackage + '.umd.js';

var npmIgnore = productionIgnore +
    `
!dist/ts/**/*.ts`;

// Ship src at root 
function shipSrc(source, destination, ignore) {
    var glob = require('glob');
    var files = glob.sync(source, {
        silent: true,
        ignore: ignore
    });
    for (var i = 0; i < files.length; i++) {
        var file = files[i].split('src/')[1];
        var target = destination + file;
        if (!fs.existsSync(path.dirname(target))) {
            shelljs.mkdir('-p', path.dirname(target));
        }
        fs.writeFileSync(target, fs.readFileSync(files[i]));
    }
}
exports.shipSrc = shipSrc;

/**
 * Create npmignore at root
 */
gulp.task('npmignore', function () {
    return createNpmIgnore(currentRepo);
});

// npmignore override
function createNpmIgnore(currentRepo, isProduction) {
    if (currentRepo !== 'ej2-build-tasks') {
        var currentIgnore, ignorePath = './.npmignore';
        try {
            if (fs.statSync(ignorePath).isFile()) {
                currentIgnore = fs.readFileSync(ignorePath);
                fs.writeFileSync(ignorePath, '');
            }
        } catch (e) { }
        if (isProduction) {
            npmIgnore = productionIgnore;
        }
        npmIgnore = currentIgnore ? npmIgnore + '\n' + currentIgnore : npmIgnore;
        if (currentRepo !== 'ej2-base-library') {
            npmIgnore = npmIgnore +
                `
            e2e/`;
        }
        fs.writeFileSync(ignorePath, npmIgnore);
    }
}
exports.createNpmIgnore = createNpmIgnore;

/**
 * Mapping typings file to package.json file
 */
gulp.task('typings-mapping', function () {
    var Addtyping = JSON.parse(fs.readFileSync('./package.json'));
    Addtyping.typings = 'index.d.ts';
    fs.writeFileSync('./package.json', JSON.stringify(Addtyping, null, '\t'), 'utf8');
});

/**
 * Publish npm packages
 */
gulp.task('publish', ['typings-mapping', 'npmignore', 'dev-registry'], function (done) {
    var simpleGit = require('simple-git')();
    if (currentRepo === 'ej2-build-tasks') {
        shipSrc('./src/services/**/*', './');
    }
    simpleGit.log(function (err, log) {
        var logs = common.getCommitDetails(log);
        if ((RegExp(regexp.COMMIT_TYPES).test(logs.lastCommit) || currentRepo === 'ej2') &&
            !RegExp(regexp.CI_SKIP).test(logs.lastCommit) && process.env.BRANCH_NAME === common.stagingBranch) {
            shelljs.exec('npm version -f ' + logs.release + ' --no-git-tag-version --no-verify');
            shelljs.exec('npm publish --registry http:' + process.env.PRIVATE_DEV_REGISTRY, function (exitCode) {
                done();
                shellDone(exitCode);
            });
        } else {
            done();
        }
    });
});

function shellDone(exitCode) {
    if (exitCode !== 0) {
        process.exit(1);
    }
}
exports.shellDone = shellDone;

/**
 * Deploy umd files in ftp location
 */
gulp.task('umd-deploy', ['ship-dist'], function (done) {
    var currentPackage = (common.currentPackage === 'ej2' ||
        common.currentPackage === 'ej2-vue-es5') ? '' : common.currentPackage;
    var location = common.isMasterBranch ? 'packages/production/' + currentPackage : 'packages/development/' + currentPackage;
    location = common.isReleaseBranch ? 'packages/release/' + currentPackage : location;
    location = common.isHotfixBranch ? 'packages/hotfix/' + currentPackage : location;
    cdn.publish('./umd-deploy', false, location, done);
});

/**
 * for angular - ship dist files
 */
gulp.task('angular-ship-dist', function () {
    var shipSrc = ['styles/**/*.css', '!styles/resources/*.css'];
    return gulp.src(shipSrc, {
        base: '.'
    })
        .pipe(gzip({
            append: false
        }))
        .pipe(gulp.dest('./umd-deploy'));
});

/**
 * Deploy umd files in ftp location only for angular
 */
gulp.task('angular-umd-deploy', ['angular-ship-dist'], function (done) {
    var currentPackage = common.currentPackage;
    var location = common.isMasterBranch ? 'packages/production/' + currentPackage : 'packages/development/' + currentPackage;
    location = common.isReleaseBranch ? 'packages/release/' + currentPackage : location;
    location = common.isHotfixBranch ? 'packages/hotfix/' + currentPackage : location;
    // Moving umd file to deploy folder
    shelljs.mkdir('./umd-deploy/dist/');
    shelljs.cp('-rf', './dist/bundles/**.umd.min.js', './umd-deploy/dist/');
    cdn.publish('./umd-deploy', false, location, done);
});

/**
 * publish js files in ftp location
 */
gulp.task('ej2-js-publish', function () {
    shelljs.exec('gulp ej2-js');
    common.EJJavascriptPublish();
});

/**
 * publish vue es5 files in ftp location
 */
gulp.task('ej2-vue-es5-publish', function () {
    shelljs.exec('gulp ej2-vue');
    common.EJVuePublish();
});

/**
 * ship dist files
 */
gulp.task('ship-dist', function () {
    var shipSrc = ['dist{,/**}', '!./dist/ts{,/**}', 'styles/**/*.css', '!styles/resources/*.css', 'styles/**/*.scss'];
    if (common.currentPackage === 'ej2') {
        shipSrc.concat(['./*.css', './*.scss']);
    }
    return gulp.src(shipSrc, {
        base: '.'
    })
        .pipe(gzip({
            append: false
        }))
        .pipe(gulp.dest('./umd-deploy'));
});

gulp.task('ci-skip', function (done) {
    var simpleGit = require('simple-git')();
    simpleGit.log(function (err, log) {
        var logs = common.getCommitDetails(log),
            coverage = '',
            stagingBranch = common.stagingBranch;
        if ((RegExp(regexp.COMMIT_TYPES).test(logs.lastCommit) || currentRepo === 'ej2') &&
            !RegExp(regexp.CI_SKIP).test(logs.lastCommit) && process.env.BRANCH_NAME === stagingBranch) {
            var user = 'SyncfusionBuild';
            var token = process.env.GithubBuildAutomation_PrivateToken;
            var origin = 'http://' + user + ':' + token + '@github.com/essential-studio/' + common.currentRepo + '.git';
            shelljs.exec('git remote set-url origin ' + origin + ' && git pull origin ' + stagingBranch);
            if (fs.existsSync('./coverage')) {
                coverage = 'coverage.txt';
                fs.writeFileSync('./' + coverage, fs.readFileSync('./coverage/report.txt'));
            }
            if (fs.existsSync(path.resolve('./current-api.json'))) {
                let apipath = path.resolve('./api.json');
                let json = JSON.stringify(require(path.resolve('./current-api.json')), null, '\t');
                fs.writeFileSync(apipath, json, 'utf-8');
            }
            shelljs.exec('git add -f package.json api.json ' + coverage);
            shelljs.exec('git commit -m \"ci-skip(EJ2-000): Branch merged and package is published [ci skip]\" --no-verify');
            shelljs.exec('git branch -f ' + stagingBranch + ' HEAD && git checkout ' + stagingBranch, shellDone);
            shelljs.exec('git push -f --set-upstream origin ' + stagingBranch + ' --no-verify', {
                silent: true
            }, function (exitCode) {
                done();
                shellDone(exitCode);
            });
        } else {
            done();
        }
    });
});

gulp.task('ej2-js-pack', function () {
    var shipSrc = ['dist{,/**}', '!./dist/*.ts', 'styles/**/*.css', 'styles/**/*.scss', '!styles/resources/*.css',
        'package.json', '.npmrc', 'license', 'ReadMe.md', 'README-ES5-Nuget.md'];
    return gulp.src(shipSrc, {
        base: '.'
    })
        .pipe(gulp.dest('./ej2-js-es5'));
});

gulp.task('ej2-vue-pack', function () {
    var shipSrc = ['dist{,/**}', '!./dist/*.ts', 'styles/**/*.css', '!styles/resources/*.css', 'package.json', '.npmrc'];
    return gulp.src(shipSrc, {
        base: '.'
    })
        .pipe(gulp.dest('./ej2-vue-es5'));
});

gulp.task('package-json', function () {
    var packageJson = JSON.parse(fs.readFileSync('./ej2-js-es5/package.json'));
    packageJson.dependencies = {};
    packageJson.name = '@syncfusion/ej2-js-es5';
    shelljs.cp('-R', ['./*.css', './combined-scss/*.scss'], './ej2-js-es5/styles');
    if (fs.existsSync('./ej2-js-es5/dist')) {
        shelljs.mv('./ej2-js-es5/dist', './ej2-js-es5/scripts');
    }
    fs.writeFileSync('./ej2-js-es5/package.json', JSON.stringify(packageJson, null, '\t'));
});

gulp.task('package-json-vue', function () {
    var packageJson = JSON.parse(fs.readFileSync('./ej2-vue-es5/package.json'));
    packageJson.dependencies = {};
    packageJson.name = '@syncfusion/ej2-vue-es5';
    if (fs.existsSync('./ej2-vue-es5/dist')) {
        shelljs.mv('./ej2-vue-es5/dist', './ej2-vue-es5/scripts');
    }
    fs.writeFileSync('./ej2-vue-es5/package.json', JSON.stringify(packageJson, null, '\t'));
});

gulp.task('publish-mvcscripts', function (done) {
    publishScripts('ej2-aspmvc-samples', './ej2-mvcsource', 'Content/styles', 'Scripts', false, done);
});

gulp.task('publish-aspscripts', function (done) {
    publishScripts('ej2-aspcore-samples', './ej2-aspsource', 'wwwroot/styles', 'wwwroot/scripts', false, done);
});

gulp.task('publish-blazor-source', function (done) {
    publishScripts('ej2-blazor-source', './blazor-source', 'Syncfusion.Blazor/wwwroot/styles', 'Scripts', true, done);
});

gulp.task('publish-blazor-sb-scripts', function (done) {
    publishScripts('ej2-blazor-samples', './ej2-blazorsource', 'ServerSide-Blazor/blazor-samples/wwwroot/styles',
        'ServerSide-Blazor/blazor-samples/wwwroot/scripts', true, done);
});


function publishScripts(sampleName, localPath, stylesPath, sourcePath, isBlazorSource, done) {
    var gitPath = 'https://' + user + ':' + token + '@github.com/essential-studio/' + sampleName;
    var gitLocalPath = localPath;
    var clone = shelljs.exec('git clone ' + gitPath + ' -b ' + branch + ' ' + gitLocalPath, { silent: true });
    if (clone.code !== 0) {
        done();
        return;
    }
    else {
        if (isBlazorSource) {
            var copyPath = localPath + '/' + sourcePath;
            //Copy ej2.min.js and theme files to blazor source
            var ej2MinJsPath = './dist/ej2.min.js';
            var themeFilesPath = glob.sync('./*.css');
            var themeCssRegex = /\/[^\.]+.css/;
            if (fs.existsSync(ej2MinJsPath) && fs.existsSync(copyPath)) {
                shelljs.cp('-r', ej2MinJsPath, copyPath);
                var placeholderCssPath = copyPath + '/placeholder.css';
                var hcplaceholderCssPath = copyPath + '/highcontrast-placeholder.css';
                var placeholderCss = fs.existsSync(placeholderCssPath) ? fs.readFileSync(placeholderCssPath, 'utf8') : '';
                var hcPlaceholderCss = fs.existsSync(hcplaceholderCssPath) ? fs.readFileSync(hcplaceholderCssPath, 'utf8') : '';
                for (var themeFilePath of themeFilesPath) {
                    shelljs.cp('-r', themeFilePath, copyPath);
                    var themeCss = themeFilePath.match(themeCssRegex)[0];
                    var themeBlazorPath = copyPath + themeCss;
                    fs.writeFileSync(themeBlazorPath, (fs.readFileSync(themeBlazorPath, 'utf8') + '\n' +
                        ((themeFilePath.indexOf('highcontrast.css') !== -1) ? hcPlaceholderCss : placeholderCss)), 'utf8');
                }
                if (fs.existsSync('./blazor-styles')) {
                    shelljs.cp('-R', './blazor-styles/*.css', localPath + '/' + stylesPath);
                }
            }
        } else {
            if (fs.existsSync('./ej2-js-es5')) {
                shelljs.cp('-R', './ej2-js-es5/styles/*.css', localPath + '/' + stylesPath);
                shelljs.cp('-R', './ej2-js-es5/scripts/*', localPath + '/' + sourcePath);
            }
        }
        shelljs.cd(localPath);
        var addFiles, message;
        if (isBlazorSource) {
            addFiles = 'git add ' + stylesPath + '/*.css';
            message = 'latest styles has been shipped';
        } else {
            addFiles = 'git add ' + sourcePath + '/ej2.min.js ' + stylesPath + '/*.css';
            message = 'latest scripts and styles has been shipped';
        }
        shelljs.exec(addFiles);
        shelljs.exec('git commit -m \"' + message + '\" --no-verify');
        shelljs.exec('git push -f --set-upstream origin --no-verify', { silent: true });
        shelljs.cd('../');
        shelljs.rm('-rf', localPath);
        done();
    }
}

gulp.task('ej2-js', function () {
    var runSequence = require('run-sequence');
    runSequence('ej2-js-pack', 'package-json', 'ej2-write-dts', 'publish-blazor-source', 
        'publish-mvcscripts', 'publish-aspscripts');
});

gulp.task('ej2-vue', function () {
    runSequence('ej2-vue-pack', 'package-json-vue');
});

// generate the style packages
function generateStylesPackages(themeName, done, isLast) {
    var path = './ej2-' + themeName;
    if (!fs.existsSync(path)) {
        shelljs.mkdir('-p', path);
        if (fs.existsSync('./ej2-js-es5')) {
            var files = glob.sync('./ej2-js-es5/styles/**/' + themeName + '.css');
            var scssFiles = glob.sync('./ej2-js-es5/styles/**/' + themeName + '.scss');
            files = files.concat(scssFiles);
            for (var j = 0; j < files.length; j++) {
                var file = files[j].split('/');
                file = file.splice(2, file.length - 3).join('/');
                shelljs.mkdir('-p', './ej2-' + themeName + '/' + file);
                shelljs.cp('-R', files[j], './ej2-' + themeName + '/' + file);
            }
            shelljs.cp('-R', './ej2-js-es5/license', './ej2-' + themeName + '/');
            var packageJson = JSON.parse(fs.readFileSync('./package.json'));
            delete packageJson.dependencies;
            delete packageJson.devDependencies;
            delete packageJson.scripts;
            packageJson.name = '@syncfusion/ej2-' + themeName + '-theme';
            fs.writeFileSync('./ej2-' + themeName + '/package.json', JSON.stringify(packageJson, null, '\t'));
            var ReadME = `# ej2-${themeName}-theme

## Setup
To install ${themeName} theme, use the following command\n\n` +

                '```sh \nnpm install @syncfusion/ej2-' + themeName + '-theme\n```\n' +

                '## License\n' +
                'This is a commercial product and requires a paid license for possession or use.' +
                'Syncfusion’s licensed software, including this component, is subject to the terms and' +
                'conditions of Syncfusion' + 's EULA (https://www.syncfusion.com/eula/es/).' +
                'To acquire a license, you can purchase one at https://www.syncfusion.com/sales/products or start a free ' +
                '30-day trial here (https://www.syncfusion.com/account/manage-trials/start-trials).\n\n' +

                'A free community license (https://www.syncfusion.com/products/communitylicense) is also available for companies and ' +
                'individuals whose organizations have less than $1 million USD in annual gross revenue and five or fewer developers.\n\n' +

                `   © Copyright 2020 Syncfusion, Inc. All Rights Reserved. 
    The Syncfusion Essential Studio license and copyright applies to this distribution.`;
            fs.writeFileSync('./ej2-' + themeName + '/README.md', ReadME);
            common.EJThemesPublish(path, done, isLast);
        }
    }
}
exports.generateStylesPackages = generateStylesPackages;

// publish the styles themewise
gulp.task('ej2-publish-styles', function (done) {
    for (var i = 0; i < themes.length; i++) {
        var isLast = i === themes.length - 1;
        generateStylesPackages(themes[i], done, isLast);
    }
});

// Shipping source to blazor-soure repo
gulp.task('blazor-library-scripts', function (done) {
    if (fs.existsSync('./dist/global/')) {
        var gitClonePath = 'https://' + user + ':' + token + '@github.com/essential-studio/ej2-blazor-source';
        var blazorClone = shelljs.exec('git clone ' + gitClonePath + ' -b ' + branch + ' ./blazor-source', { silent: true });
        if (blazorClone.code !== 0) {
            done();
            return;
        }
        else {
            var blazorPath = `./blazor-source/Scripts/modules`;
            shelljs.mkdir('-p', blazorPath);
            var currentPackage = common.currentPackage.replace('ej2', '').replace(/-/g, '');
            // copy global file to blazor source
            var scriptContent = fs.readFileSync(`./dist/global/blazor/${currentPackage}.js`, 'utf8');
            fs.writeFileSync(`${blazorPath}/${currentPackage}.js`, scriptContent);
            shelljs.cd(`./blazor-source`);
            shelljs.exec('git add .');
            shelljs.exec('git pull');
            shelljs.exec('git commit -m \"ci-skip(EJ2-000): Source shipping from ' + common.currentPackage + '\" --no-verify');
            shelljs.exec('git push');
            shelljs.cd('../');
        }
    }
});
